# GOF

## 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系


## 七大设计原则

| 设计原则   | 一句话归纳              | 目的            |
|:-------|--------------------|---------------|
| 开闭原则   | 对扩展开放，对修改关闭        | 降低维护带来的新风险    |
| 依赖倒置原则 | 高层不该依赖低层           | 利于代码结构的升级扩展   |
| 单一职责原则 | 一个类、方法只干一件事        | 便于理解，提高代码可读性  |
| 接口隔离原则 | 一个接口只干一件事          | 功能解耦，高内聚、低耦合  |
| 迪米特法则  | 只知道必须知道的           | 只和朋友交流，减少代码臃肿 |
| 里氏替换原则 | 子类重写方法，不应影响父类方法的含义 | 防止继承犯泛滥       |
| 合成复用原则 | 减少继承的使用            | 降低代码耦合        |


### 开闭原则（OCP）
Open Closed Principle: software entities (modules, classes, functions, etc.) should be open for extension ,
but closed for modification.

翻译过来就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。也就是说，添加新功能时，应该在已有代码的基础上进行扩展（新增
模块、类、方法等），而不是修改已有代码。对扩展开放是为了应对新需求，对修改关闭是为了保证已有代码的稳定性。

我们需要注意：
- 开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发，
- 同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。

为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。
在写代码的时候，多花点时间思考，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点。

开闭原则是最难理解、最难掌握、最有用的原则。扩展性是代码质量最重要的衡量标准之一。在 23 种经典设计模式中，
大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。

在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，
以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。

### 单一职责原则（SRP）
Single Responsibility Principle: A class or module should have a single reponsibility.

翻译过来就是：一个类或者模块只负责完成一个职责（或者功能）。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。
单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。

不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。

判断类的职责是否单一，我们可以参考以下几个方面：
- 类中的代码行数、函数或者属性过多
- 类依赖的其他类过多，或者依赖类的其他类过多
- 私有方法过多
- 比较难给类起一个合适的名字
- 类中大量的方法都是集中操作类中的某几个属性

遵循单一职责原则可以提高类的内聚性，减少代码耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。


### 里氏替换原则（LSP）
Liskov Substitution Principle:
- If S is a subtype of T, then objects of type T may be replaced with objects of type
S, without breaking the program.
- Functions that use pointers of references to base classes must be able to use
  objects of derived classes without knowing it.

翻译过来就是：子类对象（object of subtype / derived class）能够替换程序（program）中父类对象（object of base / parent
class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

里氏替换原则也叫 Design By Contract，翻译过来就是：按照协议设计。父类（或者是接口）定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变
函数原有的行为约定。这里的行为约定包括：**函数声明要实现的功能**；**对输入、输出、异常的约定**；甚至包括**注释中所罗列的任何特殊说明**。

虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的**角度不一样**。

多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，
用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。


### 接口隔离原则（ISP）
Interface Segregation Principle: Clients should not be forced to depend upon interfaces that they do not use.

翻译过来就是：客户端不应该强迫依赖它**不需要的接口**。其中的“客户端”，可以理解为接口的调用者或者使用者。
也就是说，如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。

我们可以把“接口”理解为：
- 单个 API 接口或函数
- 一组 API 接口集合
- OOP 中的接口概念


单一职责原则与接口隔离原则的区别：
单一职责原则针对的是模块、类、接口的设计。
接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。

接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。
如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。


### 依赖倒置原则（DIP）
Dependency Inversion Principle: High-level modules shouldn’t depend on low-level modules. Both modules
should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

翻译过来就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。
除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

e.g. Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Sevlet 规范。Servlet 规范不依
赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。

控制反转、依赖反转、依赖注入
1. 控制反转是一个比较笼统的设计思想，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在
没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。

2. 依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。
高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

3. 依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象， 
而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等 方式传递（或注入）给类来使用。

4. 我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关
系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。


### 迪米特法则（LOD）
Law of Demeter: Each unit should have only limited knowledge about other units: only units
“closely” related to the current unit. Or: Each unit should only talk to its
friends; Don’t talk to strangers.

翻译成中文就是：每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）
的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。

也就是说，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。

高内聚：相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。修改会比较集中，代码容易维护。
低耦合：在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。


### KISS 原则
有多个版本：
- Keep It Simple and Stupid.
- Keep It Short and Simple.
- Keep It Simple and Straightforward.

表达的意思其实差不多，翻译成中文就是：尽量保持简单。代码的可读性和可维护性是衡量代码质量非常重要的两个标准。KISS 原则就
是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。

我们该如何做呢：
- 不要使用同事可能不懂的技术来实现代码。比如正则表达式，还有一些编程语言中过于高级的语法等。
- 不要重复造轮子，要善于使用已经有的工具类库。自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。
- 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。


### DRY 原则
Don’t Repeat Yourself.

翻译成中文就是：不要重复自己。

一般分为以下几种重复：
- 实现逻辑重复
- 功能语义重复
- 代码执行重复


怎么提高代码复用性：
- 减少代码耦合
- 满足单一职责原则
- 模块化
- 业务与非业务逻辑分离
- 通用代码下沉
- 继承、多态、抽象、封装
- 应用模板等设计模式



## 23 种设计模式

1. 创建型
   - 常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。
   - 不常用的有：原型模式。
2. 结构型
   - 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。
   - 不常用的有：门面模式、组合模式、享元模式。
3. 行为型
   - 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。
   - 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

### 创建型
### Factory

工厂模式 : 提供创建对象的接口，就相当于 new，但可以给系统带来更大的可扩展性 和 尽量少的修改量。

如果创建实例时的初始工作比较 ==复杂==，可能是很长一段代码，如果将 很多工作 都写入构造函数，那么代码就会显得很难看，违背了单一职责原则。

工厂方法(Factory Method) 抽象工厂(Abstract Factory)。区别在于需要创建的对象的复杂程度上。



## 面向对象

**面向对象编程**是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并 将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。

**面向对象编程语言**是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面 向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

**面向过程编程**也是一种编程范式或编程风格。它以过程（可以为理解方法、函数、操作）作为组织代码的基本单元，
以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

**面向过程编程语言**首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），
仅支持面向过程编程。

OOP 的优势：
- OOP 更能应对大规模复杂程序的开发。
- OOP 风格代码更易复用、扩展、维护。
- OOP 语言更加人性化、只能、高级。

面向对象四大特性：
- 封装。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。 
  一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。
- 抽象。抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。
  一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
- 继承。表示类之间的 is-a 关系，分为两种模式：单继承和多继承。主要是用来解决代码复用的问题。
- 多态。指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。可以提高代码的扩展性和复用性。

三种违反面向对象编程风格的典型代码设计：
- 滥用 getter、setter 方法。
   在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，
   但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。
- Constants 类、Utils 类的设计问题。尽量能做到职责单一，定义一些细化的小类，避免定义大而全的类。除此之
  外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。
-  基于贫血模型的开发模式。数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的。


### 接口

接口与抽象类
- 如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；
- 如果我们要表示?一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。

基于接口而非实现编程:
- “基于抽象而非实现编程”，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，
越能提高代码的灵活性、扩展性、可维护性。
- 我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。


### 继承与组合

- 继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，
也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。

- 继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。
除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

- 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。
如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。
除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。

  